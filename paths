#include <iostream>
#include <sstream>
#include <vector>
#include <iomanip>
#include <map>
using namespace std;

/**
  THIS CODE COUNTS NUMBER OF HAMILTONIAN PATHS CONNECTING
  ANY GIVEN STARTING CELL WITH ANY GIVEN ENDING CELL.

  CELLS ARE 0-INDEXED.  TO EXCLUDE A CELL (a,b), ADD
      grid[b-1][a-1].connections = 2;

  FOR HAMILTONIAN PATHS CONNECTING TOP LEFT WITH BOTTOM LEFT:
      grid[0][0].connections   = 1;    // STARTING CELL
      grid[0][C-1].connections = 1;    // ENDING CELL
    FOR INPUT 4 X   generates http://oeis.org/A181688
    FOR INPUT 5 X   generates http://oeis.org/A181689

  FOR HAMILTONIAN PATHS CONNECTING OPPOSITE CORNERS:
      grid[0][0].connections     = 1;    // STARTING CELL
      grid[R-1][C-1].connections = 1;    // ENDING CELL
    FOR INPUT 4 X   generates http://oeis.org/A014523
    FOR INPUT 5 X   generates http://oeis.org/A014584

  FOR HAMILTONIAN CYCLES:
      grid[0][0].connections = 1;    // STARTING CELL
      grid[0][1].connections = 1;    // ENDING CELL
    FOR INPUT 4 X   generates http://oeis.org/A006864
    FOR INPUT 5 X   generates http://oeis.org/A006865
    FOR INPUT 6 X   generates http://oeis.org/A145401
    FOR INPUT 7 X   generates http://oeis.org/A145416
    FOR INPUT 8 X   generates http://oeis.org/A145418
    FOR INPUT 9 X   generates http://oeis.org/A160149
**/

// ================= BEGIN Biggy ====================
//        BASED ENTIRELY UPON:
//        https://sites.google.com/site/indy256/algo_cpp/bigint
class Biggy
{
  private:
    vector<int>  N;
    int          sign;

    static constexpr int  base       = 1000000000;
    static constexpr int  baseDigits = 9;

    int &operator [] ( int x )              { return( N[x] ); }
    const int &operator [] ( int x )  const { return( N[x] ); }
    int size()  const                       { return N.size(); }

    typedef long long    _LL;
    typedef vector<_LL>  _VLL;

  public:
    // CONSTRUCTORS
    Biggy()                   { sign = 1; }
    Biggy( _LL v )            { *this = v; }
    Biggy( const string &s )  { read( s ); }

    // COMPARISON OPERATORS
    bool operator < ( const Biggy &v ) const
    {
        if( sign != v.sign )    return sign < v.sign;
        if( size() != v.size() )
            return size()*sign < v.size()*v.sign;
        for( int i=size() - 1 ; i>=0 ; --i )
            if( N[i] != v[i] )
                return N[i]*sign < v[i]*sign;
        return false;
    }
    bool operator >  ( const Biggy &v ) const
    { return v < *this; }
    bool operator <= ( const Biggy &v ) const
    { return !( v < *this ); }
    bool operator >= ( const Biggy &v ) const
    { return !( *this < v ); }
    bool operator == ( const Biggy &v ) const
    { return !( *this < v ) && !( v < *this ); }
    bool operator != ( const Biggy &v ) const
    { return *this < v || v < *this; }

  private:
    // GETS AND SETS
    bool isNeg() const  { return sign < 0; }
    bool isZero() const {
        return N.empty() || ( size() == 1  &&  !N[0] );
    }
    _LL longValue() const {
        _LL res = 0;
        for( int i=size()-1 ; i>=0 ; --i )   res = res*base + N[i];
        return res*sign;
    }
    string toString() const  {
        ostringstream s;
        if( isNeg() )    s << '-';
        s << ( N.empty() ? 0 : N.back() );
        for( int i=size()-2 ; i>=0 ; --i )
            s << setw( baseDigits ) << setfill( '0' ) << N[i];
        return s.str();
    }

  public:
    // ASSIGNMENT OPERATORS
    void operator = ( const string &s ) { read( s ); }
    void operator = ( const Biggy &v )  { sign = v.sign;  N = v.N; }
    void operator = ( _LL v ) {
        v < 0 ? sign = -1,  v = -v : sign = 1;
        for( ; v>0 ; v=v/base )    N.push_back( v %base );
    }

    // ARITHMETIC OPERATORS
    Biggy operator + ( const Biggy &v ) const {
        if( sign == v.sign ) {
            Biggy res = v;

            for( int i=0, carry=0 ; i<max( size(), v.size() ) ||
                 carry ; ++i )
            {
                if( i == res.size() )    res.N.push_back( 0 );
                res[i] += carry + ( i < size() ? N[i] : 0 );
                carry = res[i] >= base;
                if( carry )    res[i] -= base;
            }
            return res;
        }
        return  *this - ( -v );
    }

    Biggy operator - ( const Biggy &v ) const  {
        if( sign == v.sign )
        {
            if( abs() >= v.abs() )
            {
                Biggy res = *this;
                for( int i=0, carry=0 ; i<v.size() || carry ; ++i )
                {
                    res[i] -= carry + (i < v.size() ? v[i] : 0);
                    carry = res[i] < 0;
                    if( carry )    res[i] += base;
                }
                res.trim();
                return res;
            }
            return -( v - *this );
        }
        return *this + ( -v );
    }

    Biggy operator - () const {
        Biggy res = *this;
        res.sign = -sign;
        return res;
    }
    Biggy operator * ( int v ) const  {
        Biggy res = *this;
        res *= v;
        return res;
    }
    Biggy operator * ( _LL v ) const  {
        Biggy res = v;
        res *= (*this);
        return res;
    }

    Biggy operator * ( const Biggy &v ) const  {
        vector<int> a6 = convertBase( N, baseDigits, 6 );
        vector<int> b6 = convertBase( v.N, baseDigits, 6 );
        _VLL A( a6.begin(), a6.end() );
        _VLL B( b6.begin(), b6.end() );
        while( A.size() < B.size() )    A.push_back( 0 );
        while( B.size() < A.size() )    B.push_back( 0 );
        while( A.size() & ( A.size() - 1 ) )
            A.push_back( 0 ), B.push_back( 0 );
        _VLL C = karatsubaMultiply( A, B );
        Biggy res;
        res.sign = sign*v.sign;
        for( int i=0, carry=0 ; i<C.size() ; ++i ) {
            _LL cur = C[i] + carry;
            res.N.push_back( int( cur %1000000 ) );
            carry = int( cur/1000000 );
        }
        res.N = convertBase( res.N, 6, baseDigits );
        res.trim();
        return res;
    }

    Biggy operator / ( const Biggy &v ) const {
        return divMod( *this, v ).first;
    }
    Biggy operator % ( const Biggy &v ) const {
        return divMod( *this, v ).second;
    }
    Biggy operator / ( int v ) const  {
        Biggy res = *this;
        res /= v;
        return res;
    }
    Biggy operator / ( _LL v ) const  {
        Biggy res = v;
        res = (*this)/v;
        return res;
    }
    Biggy operator % ( int v ) const  {
        if( v < 0 )    v = -v;
        int m = 0;
        for( int i=size() - 1 ; i>=0 ; --i )
            m = ( N[i] + m*(_LL)base ) %v;
        return m*sign;
    }
    _LL operator % ( _LL v ) const  {
        Biggy res = v;
        res = (*this) %res;
        return res.longValue();
    }
    static pair<Biggy, Biggy> divMod( const Biggy &A1,
           const Biggy &B1 ) {
        int norm = base/( B1.N.back() + 1 );
        Biggy A = A1.abs()*norm;
        Biggy B = B1.abs()*norm;
        Biggy Q, R;
        Q.N.resize( A.size() );

        for( int i=A.size() - 1 ; i>=0 ; --i )
        {
            R = R*base + A[i];
            int s1 = R.size() <= B.size() ? 0 : R[B.size()];
            int s2 = R.size() <= B.size() - 1 ? 0 : R[B.size() - 1];
            int d = ( (_LL)base*s1 + s2 )/B.N.back();
            R -= B*d;
            while( R < 0 )   { R += B;  --d; }
            Q[i] = d;
        }
        Q.sign = A1.sign*B1.sign;
        R.sign = A1.sign;
        Q.trim();    R.trim();
        return make_pair( Q, R/norm );
    }

    // UNARY OPERATORS
    Biggy& operator ++ ()   { (*this) = (*this) + 1; return *this; }
    Biggy operator ++ (int) { Biggy t(*this); ++(*this); return t; }
    Biggy& operator -- ()   { (*this) = (*this) - 1; return *this; }
    Biggy operator -- (int) { Biggy t(*this); --(*this); return t; }

    void operator += ( const Biggy &v )  { *this = *this + v; }
    void operator -= ( const Biggy &v )  { *this = *this - v; }
    void operator *= ( const Biggy &v )  { *this = (*this)*v; }
    void operator /= ( const Biggy &v )  { *this = (*this)/v; }
    void operator %= ( const Biggy &v )  { *this = (*this)%v; }
    void operator += ( const _LL v )     { *this = *this + v; }
    void operator -= ( const _LL v )     { *this = *this - v; }
    void operator *= ( const _LL v )     { *this = (*this)*v; }
    void operator /= ( const _LL v )     { *this = (*this)/v; }
    void operator %= ( const _LL v )     { *this = (*this)%v; }

    void operator *= ( int v ) {
        if( v < 0 )    sign = -sign, v = -v;
        for( int i=0, carry=0 ; i<size() || carry ; ++i )
        {
            if( i == size() )    N.push_back( 0 );
            _LL cur = N[i]*(_LL)v + carry;
            carry   = (int) (cur/base);
            N[i]    = (int) (cur %base);
        }
        trim();
    }
    void operator /= ( int v ) {
        if( v < 0 )    sign = -sign, v = -v;
        for( int i=size() - 1, rem = 0 ; i>=0 ; --i )
        {
            _LL cur = N[i] + rem*(_LL)base;
            N[i]    = (int) ( cur/v );
            rem     = (int) ( cur %v );
        }
        trim();
    }
    Biggy abs() const {
        Biggy res = *this;
        res.sign *= res.sign;
        return res;
    }

  private:
    // PRIVATE UTILITIES
    void trim()  {
        while( !N.empty()  &&  !N.back() )    N.pop_back();
        if( N.empty() )    sign = 1;
    }

    void read( const string &s )  {
        sign = 1;
        N.clear();
        int pos = 0;
        while( pos<s.size() && ( s[pos] == '-' || s[pos] == '+' ) )
            if( s[pos++] == '-' )    sign = -sign;
        for( int i=s.size() - 1 ; i>=pos ; i-=baseDigits )
        {
            int x = 0;
            for( int j=max( pos, i - baseDigits + 1 ) ; j<=i ; ++j )
                x = x*10 + s[j] - '0';
            N.push_back( x );
        }
        trim();
    }

    static vector<int> convertBase( const vector<int> &a,
           int oldDigits, int newDigits )
    {
        vector<_LL> p( max( oldDigits, newDigits ) + 1 );
        p[0] = 1;
        for( int i=1 ; i<p.size() ; ++i )  p[i] = p[i - 1]*10;
        vector<int> res;
        _LL cur = 0;
        int curDigits = 0;
        for( int i=0 ; i<a.size() ; ++i )
        {
            cur += a[i]*p[curDigits];
            curDigits += oldDigits;
            while( curDigits >= newDigits )
            {
                res.push_back( int( cur %p[newDigits] ) );
                cur /= p[newDigits];
                curDigits -= newDigits;
            }
        }
        res.push_back( (int) cur );
        while( !res.empty()  &&  !res.back() )
            res.pop_back();
        return res;
    }

  public:
    // FRIENDS
    friend Biggy gcd( const Biggy &a, const Biggy &b ) {
        return b.isZero() ? a : gcd( b, a %b );
    }
    friend Biggy lcm( const Biggy &a, const Biggy &b ) {
        return a/gcd( a, b )*b;
    }
    friend istream& operator >> ( istream &stream, Biggy &v ) {
        string s;   stream >> s;   v.read( s );
        return stream;
    }
    friend ostream& operator << ( ostream &stream, Biggy const &v ) {
        string s = v.toString();
        stream << s;
        return stream;
    }

  private:
    // USE KARATSUBA MULTIPLY INTERNALLY
    static _VLL karatsubaMultiply( const _VLL &A, const _VLL &B )
    {
        int n = A.size();
        _VLL res( n + n );
        if( n <= 32 )
        {
            for( int i=0 ; i<n ; ++i )
                for( int j=0 ; j<n ; ++j )
                    res[i + j] += A[i]*B[j];
            return res;
        }

        int k = n >> 1;
        _VLL a1( A.begin(), A.begin() + k );
        _VLL a2( A.begin() + k, A.end() );
        _VLL b1( B.begin(), B.begin() + k );
        _VLL b2( B.begin() + k, B.end() );

        _VLL a1b1 = karatsubaMultiply( a1, b1 );
        _VLL a2b2 = karatsubaMultiply( a2, b2 );

        for( int i=0 ; i<k ; ++i )  { a2[i] += a1[i]; b2[i] += b1[i]; }

        _VLL r = karatsubaMultiply( a2, b2 );

        for( int i=0 ; i<a1b1.size() ; ++i )  r[i]       -= a1b1[i];
        for( int i=0 ; i<a2b2.size() ; ++i )  r[i]       -= a2b2[i];
        for( int i=0 ; i<r.size() ; ++i)      res[i + k] += r[i];
        for( int i=0 ; i<a1b1.size() ; ++i )  res[i]     += a1b1[i];
        for( int i=0 ; i<a2b2.size() ; ++i )  res[i + n] += a2b2[i];

        return res;
    }
};

template <typename T>     // ALLOWS LEFT MULT BY DIFFERENT INT TYPES
Biggy operator * ( T myInt, Biggy const& x )  { return x*myInt; }
template <typename T>     // ALLOWS LEFT ADD BY DIFFERENT INT TYPES
Biggy operator + ( T myInt, Biggy const& x )  { return x + myInt; }
template <typename T>     // ALLOWS LEFT SUBT BY DIFFERENT INT TYPES
Biggy operator - ( T myInt, Biggy& x )        { return -x + myInt; }

// ================== END Biggy ====================

const int  MOD = 1000000007;
int  C, R;

class Cell;
typedef map< vector<Cell>, Biggy >  StateList;
typedef vector< vector<Cell> >      Grid;

class Cell
{
  public:
    Cell*  pathEnd;
    int    connections;

  public:
    // TWO CELLS ARE "EQUAL" IF THEY HAVE SAME  pathEnd  VALUES.
    // USED WHEN DETECTING CYCLES.
    bool operator < ( const Cell& r2 ) const
    {  return this->pathEnd < r2.pathEnd;  }
};

class Connection
{
  private:
    Cell*  m_cell;
    Cell*  m_nbr;
    Cell*  m_cellEnd;
    Cell*  m_nbrEnd;
    bool   m_connected;

  public:
    Connection( Cell* r, Cell* n )
    {
        m_cell      = r;
        m_nbr       = n;
        m_connected = false;

        if( m_cell->connections != 2  &&  m_nbr->connections != 2 )
        {
            // CHECK FOR CYCLE
            if( m_cell != m_nbr->pathEnd )
            {
                // UPDATE PATH ENDPOINTS
                m_cellEnd          = m_cell->pathEnd;
                m_nbrEnd           = m_nbr->pathEnd;
                m_connected        = true;
                m_cellEnd->pathEnd = m_nbrEnd;
                m_nbrEnd->pathEnd  = m_cellEnd;
                ++m_cell->connections;
                ++m_nbr->connections;
            }
        }
    }

    ~Connection()
    {
        // RESTORE TO ORIGINAL CONDITION
        if( m_connected )
        {
            m_cellEnd->pathEnd = m_cell;
            m_nbrEnd->pathEnd  = m_nbr;
            --m_cell->connections;
            --m_nbr->connections;
        }
    }

    inline operator bool() const { return m_connected; }
};

void solve( Grid& grid, StateList& nextStates, const Biggy&
            curCount, int row, int col, Biggy& solutions )
{
    if( col == C )
    {
        if( row + 1 == R )  solutions += curCount;
        else                nextStates[grid[row + 1]] += curCount;
        return;
    }

    Cell* cell      = &grid[row][col];
    Cell* cellRight = &grid[row][col + 1];
    Cell* cellDown  = &grid[row + 1][col];

    if( cell->connections == 2 )
        return solve( grid, nextStates, curCount, row, col + 1,
                      solutions );

    if( cell->connections == 0 )
    {
        if( auto cr = Connection( cell, cellRight ) )
            if( auto cd = Connection( cell, cellDown ) )
                solve( grid, nextStates, curCount, row, col + 1,
                       solutions );
        return;
    }

    if( auto cr = Connection( cell, cellRight ) )
        solve( grid, nextStates, curCount, row, col + 1, solutions );

    if( auto cd = Connection( cell, cellDown ) )
        solve( grid, nextStates, curCount, row, col + 1, solutions );
}

Biggy solve( Grid& grid )
{
    Biggy solutions = 0;

    // INITIALIZE  curStates  WITH FIRST ROW, SET COUNT = 1
    StateList curStates;
    curStates[grid[0]] = 1;

    for( int row=0 ; row<R ; ++row )
    {
        StateList nextStates;

        for( auto cur : curStates )
        {
            // PLACE CURRENT STATE IN ROW  row
            grid[row]      = cur.first;
            Biggy curCount = cur.second;

            // ENSURE pathEnd POINTS TO cell FOR ALL col ENTRIES.
            for( int col=0 ; col<C ; ++col )
            {
                Cell* cell             = &grid[row][col];
                cell->pathEnd->pathEnd = cell;
            }
            solve( grid, nextStates, curCount, row, 0, solutions );
        }
        curStates = nextStates;
    }
    return solutions;
}


int main()
{
    cin >> C >> R;  // SWAP row AND col

    // WE EXAMINE GRID BY ROWS.  ADD EXTRA COL AT END AND ROW AT
    // BOTTOM TO MARK LIMITS.  ASSIGN THESE CELLS 2 CONNECTIONS
    // SO ARE NOT USED.
    Grid  grid( R + 1 );

    for( int r=0 ; r<=R ; ++r )
    {
        grid[r].resize( C + 1 );

        for( int c=0 ; c<=C ; ++c )
        {
            Cell* cell    = &grid[r][c];
            cell->pathEnd = cell;
            if( c < C  &&  r < R )    cell->connections = 0;
            else                      cell->connections = 2;
        }
    }

    // MODIFY HERE TO CHANGE START/END CELLS
    grid[0][0].connections   = 1;    // STARTING CELL
    grid[0][C-1].connections = 1;    // ENDING CELL

    Biggy ans = solve( grid );

    cout << "Rows: " << C << "  Cols: " << R << endl;
    cout << "Paths:  " << ans << endl;
    cout << "Paths mod " << MOD << ":  " << ans %MOD << endl;

    return 0;
}
